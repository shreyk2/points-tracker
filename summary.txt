1. Why did you choose the tools, libraries, and language you used for the coding exercise?

When deciding the language to use, my first thought was the functionality of objects, which I believed would be helpful for modeling transactions and handling entities like payers and points. This led me to choose Java, as it offers strong support for object-oriented programming, which was ideal for representing the transactions. Also for time's sake, I wanted to choose a language with syntax that I felt comfortable with, and I've had multiple years of experience coding in Java so it was a pretty obvious choice for me.
I chose Spring Boot as the main framework for developing the REST API because it simplifies Java-based application development with minimal configuration. It has helpful dependency injection capabilities and built-in support for REST endpoints which made it the perfect choice for rapidly building a clean and modular backend service. I opted for the Maven build for Spring Boot in order to effectively manage the large amount of dependencies required. Additionally, I have had experience working with Spring Boot this summer, specifically with implementing REST endpoints for a CQRS system architecture. 
For testing purposes, since there weren't too many moving parts, I focused less on integration tests and more on unit tests to ensure that each functionality was working. I used JUnit as it was easy to integrate with Maven and is typically the de facto standard for unit testing in Java. For this project Mockito was pretty useful for creating mock repository interactions so that I could test the service in isolation rather than having to simulate all the dependencies.

2. What are the advantages and disadvantages of your solution?

One of the biggest advantages of my solution is the use of Spring Boot, while the current problem is very low-level, the potential for scalability is great. I mimicked the MVC design pattern which allowed for a much more modular design and made this service easy to understand and build a production-level application from. Connection to a database, while unnecessary and slow for the scope of this project, would be a relatively simple task, only replacing a few lines in the code. Another important advantage is the unit tests which allow for precise and isolated tests on the service without having to send dummy requests to the server. Testing is a crucial aspect of any backend system because ensuring the accuracy of data provided to a frontend is vital for the functionality and reliability of the entire application. 
One of the biggest disadvantages is the readability of Spring Boot as it tends to have a lot of confusing boilerplate that might confused any reader that is unfamiliar with the syntax. Java and Spring Boot also tend to have a lot more setup compared to lighter frameworks like Flask with Python which hinders speedy testing. 

3. What has been a favorite school/personal project thus far? What about it that challenged you?

I've had a few notable personal projects, but my most recent one, Curio, stands out as my favorite. With earlier personal projects, my aim was typically to build a working frontend with a scrappy backend that fulfilled my bare minimum requirements to function and test. Before this summer, I had experimented with backend tools here and there, but never really understood deeply how system architecture worked at that level. It wasn't until I took a deep interest in backend systems during my internship this summer with TAO Digital in Taiwan that I really understood the purpose of a backend and how to implement one. As the summer ended, I was determined to finally develop a full-stack application that could be pushed to production as a working product, something I hadn't done before.
In came the perfect opportunity during the MadHacks hackathon, where my team and I decided to tackle personalized learning for students. The application was designed for teachers to be able to personalize their generic worksheets and assignments according to the student's interests in order to make learning more engaging for them. While the results of the hackathon didn't end up in our favor, this was the first project I felt all the skills I acquired over the last couple of years come together. Whether it was horizontal/vertical prototyping and storyboarding that I learned about from my HCI course (CS 570), or how to containerize engines on Docker from my internship this summer. When working on the application, I finally felt that my choices were deliberate and backed up by real industry practices rather than randomly developing and hoping it all came together. With all this knowledge, setting up a full-stack application was much cleaner than when I had tried it in the past, and I almost felt that everything was going to work. ALMOST.
The one thing I had yet to tackle was deployment, hence the "almost", which is where most of my challenges were. Throughout the process of developing Curio, we worked on a local development environment, and all the testing was done through localhost, but this was not a finished product and I felt unsatisfied. With a few hours left in the hackathon, I turned my focus toward deployment, a completely novel task for me. With no idea where to begin and a (relatively) messy GitHub, it almost felt hopeless to attempt to deploy, especially since nobody else on my team knew how to either. After watching a YouTube video or two, I began to realize that hosting a web application was essentially dumping parts of the application onto different web servers, where instead of using localhost, we would use actual IP addresses to make API calls. From there, I learned how to deploy our Express.js backend, and our React frontend, and to host our engine on a virtual machine. By breaking this seemingly insurmountable task into smaller pieces that I could understand, and from there it only took another 2 hours. When I thought everything seemed to be working, I realized a core issue which was that my team had been making improvements to the application during this time, but I had deployed an old version of the application even though it had only been 2 hours. I remembered a phrase that I had learned from my summer internships, "pushing to production", which I had never understood until that day. With only 15 minutes left in the hackathon, I moved all the most current code to a production branch of the repository and fed a direct connection to Vercel, which then allowed us to display the most current version of our code, the one in our production branch.  My learnings from this project were great, finally developing a full stack application from ideation, to prototype, to development, to production, a product I have never achieved before. 